"""
Recruiter Workflow Enhancements
================================

Features for in-house recruiters:
1. Lock JD for session (fast candidate screening)
2. Candidate history tracking
3. One-page hiring summary generator
4. Shortlist management
5. Collaboration features (notes, clipboard export)
"""

from dataclasses import dataclass, field
from typing import List, Dict, Optional
from datetime import datetime
import json


@dataclass
class CandidateRecord:
    """Track analyzed candidates for session history."""
    candidate_id: str
    candidate_name: str
    analyzed_date: str
    fit_score: float
    jd_name: str
    validated_skills_count: int
    priority_skills_validated: int
    recommendation: str
    notes: str = ""
    shortlisted: bool = False
    
    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            "Candidate ID": self.candidate_id,
            "Candidate Name": self.candidate_name,
            "Date": self.analyzed_date,
            "Fit Score": f"{self.fit_score:.0%}",
            "JD": self.jd_name,
            "Validated Skills": self.validated_skills_count,
            "Priority Skills": self.priority_skills_validated,
            "Recommendation": self.recommendation,
            "Notes": self.notes,
            "Shortlisted": "Yes" if self.shortlisted else "No"
        }


@dataclass
class HiringSummary:
    """One-page hiring summary for managers."""
    candidate_name: str
    jd_title: str
    analysis_date: str
    overall_fit: float
    recommendation: str  # "HIRE", "HIRE_AND_TRAIN", "KEEP_SEARCHING"
    top_strengths: List[Dict[str, str]]  # [{skill, explanation}, ...]
    top_gaps: List[Dict[str, str]]  # [{skill, training_time}, ...]
    priority_skills_status: str
    estimated_training_months: int
    next_steps: str
    
    def to_markdown(self) -> str:
        """Generate markdown summary."""
        # Recommendation icons
        rec_icons = {
            "HIRE_AS_IS": "üü¢ RECOMMEND HIRE",
            "HIRE_AND_TRAIN": "üü° HIRE WITH TRAINING",
            "KEEP_SEARCHING": "üî¥ KEEP SEARCHING"
        }
        
        md = f"""# HIRING SUMMARY: {self.candidate_name}

**Position:** {self.jd_title}  
**Analysis Date:** {self.analysis_date}  
**Overall Fit:** {self.overall_fit:.0%}

---

## üéØ RECOMMENDATION: {rec_icons.get(self.recommendation, self.recommendation)}

{self.next_steps}

---

## ‚úÖ TOP STRENGTHS

{chr(10).join(f"**{i+1}. {s['skill']}**  \n   {s['explanation']}" for i, s in enumerate(self.top_strengths))}

---

## üìä PRIORITY SKILLS

{self.priority_skills_status}

---

## ‚ö†Ô∏è KEY GAPS

{chr(10).join(f"**{i+1}. {g['skill']}**  \n   Training needed: {g['training_time']}" for i, g in enumerate(self.top_gaps)) if self.top_gaps else "*No significant gaps*"}

---

## üìÖ NEXT STEPS

{self._generate_next_steps()}

---

*Generated by JobFit Analyzer on {self.analysis_date}*
"""
        return md
    
    def to_html(self) -> str:
        """Generate HTML summary."""
        rec_colors = {
            "HIRE_AS_IS": "#28a745",
            "HIRE_AND_TRAIN": "#ffc107",
            "KEEP_SEARCHING": "#dc3545"
        }
        color = rec_colors.get(self.recommendation, "#6c757d")
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hiring Summary - {self.candidate_name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; }}
        h1 {{ color: #333; border-bottom: 3px solid {color}; padding-bottom: 10px; }}
        h2 {{ color: #555; margin-top: 30px; }}
        .meta {{ color: #666; font-size: 14px; }}
        .recommendation {{ background: {color}; color: white; padding: 15px; border-radius: 5px; font-size: 18px; font-weight: bold; text-align: center; margin: 20px 0; }}
        .strength, .gap {{ margin: 15px 0; padding: 10px; background: #f8f9fa; border-left: 4px solid #007bff; }}
        .strength strong, .gap strong {{ color: #007bff; }}
        .footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #999; font-size: 12px; text-align: center; }}
    </style>
</head>
<body>
    <h1>HIRING SUMMARY: {self.candidate_name}</h1>
    
    <div class="meta">
        <strong>Position:</strong> {self.jd_title}<br>
        <strong>Analysis Date:</strong> {self.analysis_date}<br>
        <strong>Overall Fit:</strong> {self.overall_fit:.0%}
    </div>
    
    <div class="recommendation">
        RECOMMENDATION: {self.recommendation.replace('_', ' ')}
    </div>
    
    <p><strong>{self.next_steps}</strong></p>
    
    <h2>‚úÖ TOP STRENGTHS</h2>
    {chr(10).join(f'<div class="strength"><strong>{i+1}. {s["skill"]}</strong><br>{s["explanation"]}</div>' for i, s in enumerate(self.top_strengths))}
    
    <h2>üìä PRIORITY SKILLS</h2>
    <p>{self.priority_skills_status}</p>
    
    <h2>‚ö†Ô∏è KEY GAPS</h2>
    {chr(10).join(f'<div class="gap"><strong>{i+1}. {g["skill"]}</strong><br>Training needed: {g["training_time"]}</div>' for i, g in enumerate(self.top_gaps)) if self.top_gaps else '<p><em>No significant gaps</em></p>'}
    
    <h2>üìÖ NEXT STEPS</h2>
    <p>{self._generate_next_steps()}</p>
    
    <div class="footer">
        Generated by JobFit Analyzer on {self.analysis_date}
    </div>
</body>
</html>
"""
        return html
    
    def _generate_next_steps(self) -> str:
        """Generate next steps based on recommendation."""
        if self.recommendation == "HIRE_AS_IS":
            return "1. Schedule technical interview\n2. Verify top skills with targeted questions\n3. Check references"
        elif self.recommendation == "HIRE_AND_TRAIN":
            return f"1. Phone screen to assess cultural fit\n2. Discuss {self.estimated_training_months}-month training plan\n3. Technical assessment on strengths\n4. Offer contingent on training commitment"
        else:
            return "Continue sourcing candidates with better skill match"
    
    def to_clipboard_format(self) -> str:
        """Generate short format for ATS/Slack."""
        return f"""**{self.candidate_name}** - {self.jd_title}
Fit: {self.overall_fit:.0%} | Recommendation: {self.recommendation.replace('_', ' ')}

Top Skills: {', '.join(s['skill'] for s in self.top_strengths[:3])}
Gaps: {', '.join(g['skill'] for g in self.top_gaps[:2]) if self.top_gaps else 'None'}

{self.next_steps.split(chr(10))[0]}
"""


class CandidateHistoryManager:
    """Manage candidate analysis history."""
    
    def __init__(self):
        self.history: List[CandidateRecord] = []
        self.max_history = 50  # Keep last 50 candidates
    
    def add_candidate(self, record: CandidateRecord):
        """Add candidate to history."""
        self.history.insert(0, record)  # Most recent first
        
        # Trim to max history
        if len(self.history) > self.max_history:
            self.history = self.history[:self.max_history]
    
    def get_recent(self, count: int = 10) -> List[CandidateRecord]:
        """Get most recent candidates."""
        return self.history[:count]
    
    def get_by_jd(self, jd_name: str) -> List[CandidateRecord]:
        """Get candidates analyzed for specific JD."""
        return [c for c in self.history if c.jd_name == jd_name]
    
    def get_shortlisted(self, jd_name: Optional[str] = None) -> List[CandidateRecord]:
        """Get shortlisted candidates."""
        candidates = self.history
        if jd_name:
            candidates = [c for c in candidates if c.jd_name == jd_name]
        return [c for c in candidates if c.shortlisted]
    
    def update_shortlist(self, candidate_id: str, shortlisted: bool):
        """Update shortlist status."""
        for record in self.history:
            if record.candidate_id == candidate_id:
                record.shortlisted = shortlisted
                break
    
    def add_notes(self, candidate_id: str, notes: str):
        """Add notes to candidate record."""
        for record in self.history:
            if record.candidate_id == candidate_id:
                record.notes = notes
                break
    
    def export_to_json(self) -> str:
        """Export history as JSON."""
        return json.dumps([r.to_dict() for r in self.history], indent=2)
    
    def load_from_json(self, json_str: str):
        """Load history from JSON."""
        data = json.loads(json_str)
        # Reconstruct CandidateRecord objects
        # (Simplified - in production would properly deserialize)
        self.history = []


class HiringSummaryGenerator:
    """Generate one-page hiring summaries for managers."""
    
    @staticmethod
    def generate(
        candidate_name: str,
        jd_title: str,
        fit_score: float,
        validated_skills: List,
        missing_skills: List,
        priority_skills: List[str],
        gap_analysis = None
    ) -> HiringSummary:
        """
        Generate hiring summary from analysis results.
        
        Args:
            candidate_name: Candidate name/ID
            jd_title: Job title
            fit_score: Overall fit score
            validated_skills: List of validated skills
            missing_skills: List of missing skills
            priority_skills: Priority skills list
            gap_analysis: SkillsGapAnalysisReport (optional)
        
        Returns:
            HiringSummary object
        """
        # Determine recommendation
        if gap_analysis:
            recommendation = gap_analysis.hire_train_decision.decision
            estimated_training = gap_analysis.hire_train_decision.training_investment_months
        else:
            if fit_score >= 0.85:
                recommendation = "HIRE_AS_IS"
                estimated_training = 0
            elif fit_score >= 0.70:
                recommendation = "HIRE_AND_TRAIN"
                estimated_training = 3
            else:
                recommendation = "KEEP_SEARCHING"
                estimated_training = 0
        
        # Extract top 5 strengths
        top_strengths = []
        for skill in validated_skills[:5]:
            explanation = HiringSummaryGenerator._explain_strength(skill)
            top_strengths.append({
                "skill": skill.skill_name,
                "explanation": explanation
            })
        
        # Extract top 3 gaps
        top_gaps = []
        priority_set = set(s.lower() for s in priority_skills)
        
        # Prioritize missing priority skills
        priority_missing = [s for s in missing_skills if s.skill_name.lower() in priority_set]
        other_missing = [s for s in missing_skills if s.skill_name.lower() not in priority_set]
        
        for skill in (priority_missing + other_missing)[:3]:
            training_time = HiringSummaryGenerator._estimate_training_time(skill.skill_name)
            top_gaps.append({
                "skill": skill.skill_name,
                "training_time": training_time
            })
        
        # Priority skills status
        priority_validated = sum(
            1 for s in validated_skills
            if s.skill_name.lower() in priority_set
        )
        total_priority = len(priority_skills)
        
        if priority_validated == total_priority:
            priority_status = f"‚úÖ All {total_priority} priority skills validated"
        else:
            priority_status = f"‚ö†Ô∏è {priority_validated}/{total_priority} priority skills validated"
        
        # Next steps
        if recommendation == "HIRE_AS_IS":
            next_steps = "Strong match - recommend scheduling technical interview immediately."
        elif recommendation == "HIRE_AND_TRAIN":
            next_steps = f"Good foundation with {estimated_training}-month training path. Recommend phone screen to assess learning aptitude."
        else:
            next_steps = "Skill gaps too significant. Continue searching for better-matched candidates."
        
        return HiringSummary(
            candidate_name=candidate_name,
            jd_title=jd_title,
            analysis_date=datetime.now().strftime("%Y-%m-%d %H:%M"),
            overall_fit=fit_score,
            recommendation=recommendation,
            top_strengths=top_strengths,
            top_gaps=top_gaps,
            priority_skills_status=priority_status,
            estimated_training_months=estimated_training,
            next_steps=next_steps
        )
    
    @staticmethod
    def _explain_strength(skill) -> str:
        """Generate brief explanation of skill strength."""
        if hasattr(skill, 'experience_depth'):
            depth = skill.experience_depth.value
        else:
            depth = "Validated"
        
        if hasattr(skill, 'enhanced_evidence') and skill.enhanced_evidence:
            evidence = skill.enhanced_evidence[0]
            if hasattr(evidence, 'has_metrics') and evidence.has_metrics:
                return f"{depth} level with measurable project outcomes"
            else:
                return f"{depth} level with hands-on project experience"
        
        return f"{depth} level experience"
    
    @staticmethod
    def _estimate_training_time(skill_name: str) -> str:
        """Estimate training time for a skill."""
        # Simplified - could be more sophisticated
        skill_lower = skill_name.lower()
        
        if any(term in skill_lower for term in ['aws', 'kubernetes', 'azure', 'gcp']):
            return "2-3 months"
        elif any(term in skill_lower for term in ['python', 'java', 'javascript']):
            return "3-6 months"
        elif any(term in skill_lower for term in ['react', 'angular', 'vue']):
            return "1-2 months"
        else:
            return "2-4 months"


def explain_score_to_manager(
    fit_score: float,
    validated_count: int,
    priority_validated: int,
    total_priority: int,
    has_metrics: bool
) -> str:
    """
    Generate plain-English explanation of fit score for managers.
    
    Args:
        fit_score: Overall fit percentage
        validated_count: Number of validated skills
        priority_validated: Priority skills validated
        total_priority: Total priority skills
        has_metrics: Whether evidence includes metrics
    
    Returns:
        Plain-English explanation
    """
    reasons = []
    
    # Priority skills
    if priority_validated == total_priority:
        reasons.append(f"all {total_priority} must-have skills are verified")
    elif priority_validated >= total_priority * 0.75:
        reasons.append(f"{priority_validated} of {total_priority} must-have skills verified")
    else:
        reasons.append(f"only {priority_validated} of {total_priority} must-have skills verified")
    
    # Overall validated skills
    if validated_count >= 8:
        reasons.append(f"{validated_count} skills with hands-on evidence")
    elif validated_count >= 5:
        reasons.append(f"{validated_count} verified skills")
    else:
        reasons.append(f"only {validated_count} skills verified")
    
    # Metrics
    if has_metrics:
        reasons.append("includes measurable project outcomes")
    
    # Construct explanation
    if fit_score >= 0.85:
        return f"**High score** because: {', '.join(reasons)}."
    elif fit_score >= 0.70:
        return f"**Good score** because: {', '.join(reasons)}."
    elif fit_score >= 0.60:
        return f"**Moderate score** because: {', '.join(reasons)}."
    else:
        return f"**Low score** because: {', '.join(reasons)}."


if __name__ == "__main__":
    print("Recruiter Workflow Enhancements - Ready")
